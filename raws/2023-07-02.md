# How I made this blog

***Work in progress!***

*A detailed guide on how I built this blog using Python and the Nicegui library.*

I've been thinking of starting a public blog for years and the [Python Bytes Podcast's coverage](https://pythonbytes.fm/episodes/show/342/dont-believe-those-old-blogging-myths) of [Julia Evan's blog about Some blogging myths](https://jvns.ca/blog/2023/06/05/some-blogging-myths/#myth-everyone-should-blog) finally convinced me that I had to make my move.

I plan on making this blog mostly about Python programming, electrical engineering and perhaps some other personnal hobbies. I don't have a fixed schedule yet; we'll see how it goes!

It seemed pretty obvious that my first post should be about the making of this blog.

## This guide's assumptions

I assume some basic Python and Linux knowledge throughout this blog. I'm working with Python 3.8+ on my laptop and my Debian server. I don't believe any component requires specific versions of any package or library, apart from f-strings (of course), therefore I didn't use any virtual environment for this project.

## My plan

I have already developped a private Python blog about decade ago with no particular framework or library, and have since developped several web applications with [Django](https://www.djangoproject.com/). This time I want to take the opportunity to learn [Nicegui](https://nicegui.io/), a neat library I plan on using for several non-web GUI applications (also heard from [Python Bytes](https://pythonbytes.fm/episodes/show/329/creating-very-old-python-code)).

Since this will serve as a tutorial, I want to keep the first version of my blog as simple as possible. Therefore, there is currently no comment & search feature and social media site integration. Those might be added later.

I want to prepare my posts in either [Markdown](https://en.wikipedia.org/wiki/Markdown) or in [jupyter notebooks](https://jupyter.org/); the former can be rendered directly by Nicegui but the latter will need to be converted to HTML.

I'll use a [Makefile](https://en.wikipedia.org/wiki/Make_(software)#Makefiles) to manage the whole thing, from converting notebooks to HTML to testing and publishing.

Finally, I'll use [Nginx](https://nginx.org/en/) to serve the site, [Certbot](https://certbot.eff.org/) to manage the certificate, my existing [Vultr](https://www.vultr.com/) server to host everything and [FreeDNS](https://freedns.afraid.org/) to link my new domain name to the server's static address.

### Aesthetics

I want the blog to be lean; black on white, no distraction. Everything that draws the eyes should be relevant content. [Nicegui](https://nicegui.io/)'s defaults are great for this.

## Project structure

The overall project structure should look like this (*files* & **folders**):

 - **configs**: [Nginx](https://nginx.org/en/) and [systemd](https://www.freedesktop.org/wiki/Software/systemd/) configuration files.
 - **raws**: Markdown and jupyter notebooks - raw articles.
 - **web**: What will be served on the web.
   - **articles**: Markdown and HTML articles, ready for presentation.
   - **briefs**: 400 character summaries of each article.
   - **media**: Media files presented by the articles.
   - **static**: Static files.
   - *about.md*: Content of the `/about` page.
   - *main.py*: Blog program.
 - *Makefile*: Housekeeping.
 - *manage.py*: More advanced housekeeping, ex.:Conversion of raw articles to presentable articles and briefs.
 - *README.md*: A basic file which should refer to this page.

 This whole structure is stored in my home directory under: `/home/michel/blog`

### Makefile - Basic housekeeping stuff

The *Makefile* is used to publish (convert raw articles and generate briefs) with `make` or `make publish`, install dependencies with `make deps` and launch the website with `make serve`:

```makefile
RAW_DIR := raws

# Determine the operating system
ifeq ($(OS),Windows_NT)
	# Windows
	PYTHON := py
else
	# Linux
	PYTHON := python3
endif

# Define the publish target
publish: $(patsubst $(RAW_DIR)/%,%,$(wildcard $(RAW_DIR)/*))
	@echo "Publishing completed."

# Pattern rule to specify how to build each file
%: $(RAW_DIR)/%
	@echo "Processing $<"
	$(PYTHON) ./manage.py --file_path "$<"

# Install dependencies
deps:
	$(PYTHON) -m pip install -U pip
	$(PYTHON) -m pip install -U click logzero nicegui pathlib pipx
	$(PYTHON) -m pipx install black

# Launch the website
serve:
	$(PYTHON) ./web/main.py
```

Without going too much into details (this isn't a Makefile guide), I learned a few handy things while preparing this one:

 - ChatGPT can help generate Makefiles!
 - `$<` refers to the current target's trigger.
 - An `@` at the beginning of the line avoids showing the line in the console output (juste its outcome, ex.: what you actually want to echo).

### manage.py - Somewhat advanced housekeeping

This file will be used to convert jupyter notebooks to HTML, generate 400-character summaries of each article in `web/briefs`, and copy the presentable articles to `web/articles`.

At the moment it only handles Markdown files but [jupyter](https://jupyter.org/) and [pandoc](https://pandoc.org/) will handle this easily in the future.

> Code bloc comments follow each bloc.

```python
import click
import re
import shutil


def get_first_400_characters(file_path: str) -> str:
    with open(file_path, 'r', encoding='utf-8') as file:
        content = file.read()

    # Remove Markdown hyperlinks
    content_without_links = re.sub(r'\[(.*?)\]\((.*?)\)', r'\1', content)

    # Get the first 400 characters (approximately)
    first_400_characters = content_without_links[:400]

    return first_400_characters
```

The `get_first_400_characters` is self-explanatory, but it strips URLs and control characters of Markdown hyperlinks to keep the summary readable.

```python
@click.command()
@click.option("--file_path", type=str, default=None)
def main(file_path: str):
    if file_path is not None:
        file_name = file_path.split("/")[1]
        with open(f"web/briefs/{file_name}", "w", encoding='utf-8') as file:
            file.write(get_first_400_characters(file_path))
            file.write("...")

        shutil.copy(file_path, f"web/articles/{file_name}")


if __name__ == "__main__":
    main()
```

The `main` function handles the file path argument, calls `get_first_400_characters`, saves the summary and copies the article. I solved an issue I had with the file copy with [this response on stackoverflow](https://stackoverflow.com/a/33626207).

### main.py - The brains of the operation

Calling it "brains" might be a strech, but it does handle the whole website with a few lines of code thanks to [Nicegui](https://nicegui.io/).

> Code bloc comments follow each bloc.

```python
import datetime
from nicegui import ui
from pathlib import Path


__title__ = "Code & Currents - Michel Lavoie's blog"


briefs_dir = Path("web/briefs")
briefs_list = sorted(list(briefs_dir.glob("*")), reverse=True)

articles_dir = Path("web/articles")
articles_list = sorted(list(articles_dir.glob("*")), reverse=True)

body_classes = "mx-auto sm:max-w-full"
body_style = "max-width: 768px;"
```

My articles are named by publication date (ISO format), so they can simply be sorted alphabetically to get them in chronological order. The `body_classes` and `body_style` are from [tailwind CSS](https://tailwindcss.com/); the `mx-auto` class centers the element horizontally on the page, the `sm:max-w-full` sets the element's width to the whole screen on small devices (ex.: on smartphones), and the `max-widgth` style sets the maximum width to a fixed value otherwise (ex.: on PC).

> I believe it should have worked with everything enclosed in the class (ex.: with the `max-widgth` style replaced with a `max-w-screen-lg` class), but for some reason I couldn't make it work.

```python
def briefs():
    for brief_path in briefs_list:
        if brief_path.is_file():
            # Show the card brief
            x = brief_path
            with ui.card().classes("container mx-auto").on(
                "click",
                lambda x=x: ui.open(f"/article/{x.stem}"),
            ):
                with ui.row():
                    if brief_path.suffix == ".md":
                        ui.markdown(brief_path.read_text()).style("color: #555555")
                    elif brief_path.suffix == ".html":
                        ui.html(brief_path.read_text()).style("color: #555555")
                with ui.row().style("width: 100%").classes("flex justify-end"):
                    ui.link("Read article", f"/article/{brief_path.stem}")
                    ui.label(f"Posted on {brief_path.stem}")
```

The `briefs` function presents each articles's summary as a card, those cards can be clicked anywhere to reach the full article. One bit that really bugged me was that without the `x=x` bit on the following line, clicking on any card would always open the last one in the list:

```python
with ui.card().classes("container mx-auto").on(
    "click",
    lambda x=x: ui.open(f"/article/{x.stem}"),
):
```

User *catamountjack* provided the answer on [Nicegui](https://nicegui.io/)'s Discord server.

```python
def header():
    with ui.header().style("background-color: #F0F0F0").classes(
        "items-center place-content-center"
    ):
        ui.label(__title__).style("color: #111111")
        ui.link("Home", "/")
        ui.link("About", "/about")
```

A simple, lean but always visible header with basic hyperlinks (I plan on adding a search bar once there are enough articles to justify it).

```python
def copyright():
    year = datetime.datetime.now().year
    with ui.expansion(f"Copyright Â© {year} Michel Lavoie. All rights reserved.").style(
        "color: #555555"
    ):
        ui.label(
            "Unauthorized use and/or duplication of this material without express and \
written permission from this blog's author and/or owner is strictly prohibited. \
Excerpts and links may be used, provided that full and clear credit is given to \
Michel Lavoie and [Your Blog's Name] with appropriate and specific direction to the \
original content."
        )
```

I like having an adequate copyright notice that's not always visible, so I used an expandable container.

```python
@ui.page("/")
def home():
    header()
    with ui.grid(columns=1).classes(body_classes).style(body_style):
        briefs()
        copyright()
```

The homepage only contains the *briefs*, which are the clickable cards with a summary of each article.

```python
@ui.page("/about")
def about():
    header()
    with ui.grid(columns=1).classes(body_classes).style(body_style):
        ui.markdown(Path("web/about.md").read_text())
        copyright()
```

This one is a small bio which could be extended later.

```python
@ui.page("/article/{date}")
def view_article(date: str):
    header()
    with ui.grid(columns=1).classes(body_classes).style(body_style):
        for article_path in articles_list:
            if date in article_path.stem:
                if article_path.suffix == ".md":
                    ui.markdown(article_path.read_text())
                elif article_path.suffix == ".html":
                    ui.html(article_path.read_text())
                break
        copyright()
```

For this page I learned you could use a `{keyword}` this way in the relative path (in `ui.page`) as a Python variable name; this allows me to keep the code fully dynamic and only create the raw article and use the Makefile to publish new articles.

```python
if __name__ == "__main__":
    ui.run(title=__title__)
```

This condition that checks whether the python module is imported or run as the main program (it's always the main program in this case).

## What's next?

The next step is likely to be the integration of Jupyter Notebooks to `manage.py`, and perhaps adjustements to the site presentation.

As mentioned above, I aimed to keep this first version of the blog as simple as possible for a number of reasons. Moving forward I anticipate the site would benefit from [...]